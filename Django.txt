---------
DJANGO
---------

Source: 	https://www.youtube.com/watch?v=F5mRW0jo-U4
Code:   	https://github.com/codingforentrepreneurs/Try-Django
Setup:  	joincfe.com/from-zero
env:    	django
activate: 	cd ~/Dev/venv/ && source bin/activate
windows ubuntu: cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango && source bin/activate
-------------------------------------------------------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-------------------------------------------------------------------------------------------------
CREATING A NEW DJANGO PROJECT
-----------------------------

Launch django:	cd src && python manage.py runserver
Sync Settings:	python manage.py migrate

--------------------------------------------------
Create superuser: python manage.py createsuperuser
--------------------------------------------------
username:	saeed
password:	default password + 'a'

Create apps: 	python manage.py startapp products
		python manage.py startapp yaomul-khamis

Add apps:	python manage.py makemigrations
		python manage.py migrate

Shell Add:	cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango/src && python manage.py shell
		>>> from products.models import Product
		>>> Product.objects.all()
		<QuerySet [<Product: Product object (1)>]>
		>>> Product.objects.create(title='New products2', description='Itssanother one', price='9.99', summary='Sweetness') 
		<Product: Product object (2)>
		>>> Product.objects.all()
		<QuerySet [<Product: Product object (1)>, <Product: Product object (2)>]>
		>>> Product.objects.create(title='New products3', description='Itssanother one, again', price='9.99', summary='Awesomeness')
		>>> Product.objects.all()
		<QuerySet [<Product: Product object (1)>, <Product: Product object (2)>, <Product: Product object (3)>]>

----------------
NEW MODEL FIELDS
----------------
Star over:	Delete all the files in the products >> migrations folder including __pycache__ folder except the __init__.py file
		Delete the sqlite database under the src tree
		
"python manage.py createsuperuser": this is because the sqlite database was deleted

Field types:	Use django documentation to find different field types to use

Shell Add with the new fields:
		>>> from products.models import Product
		>>> Product.objects.create(title='Newer title', price=29.99, summary='Awesomeness')
		<Product: Product object (2)>

--------------
CHANGE A MODEL
--------------
trydjango >> src >> products >> model.py

Make a change to the model without deleting the database
When we run "python manage.py makemigrations", it syncs our database to the model
However, if we add a field to our model, we need to let the database know
The command, "python manage.py makemigrations", allows the database to know about the changes

# blank=True, null=False  makes the 'Summary' not bold and not essential to be filled before saving in server admin
# blank=False, null=False  makes the 'Summary' bold and essential to be filled before saving in server admin
# 'blank' has to do with how the field is rendered
# 'null' has to do with the database
# 'blank=False' means it is required
# 'null=False' means the database can be empty

-----------------------------------
DEFAULT HOMEPAGE TO CUSTOM HOMEPAGE
-----------------------------------
Create a new app called pages:
	python manage.py startapp pages

Add the new app, pages to settings.py under INSTALLED APPS = [...]
	trydjango >> src >> trydjango >> settings.py

Navigate to views.py
	trydjango >> src >> pages >> views.py

Build the homepage function in views.py
Import the views.py code into urls.py
	trydjango >> src >> trydjango >> urls.py
Add the home view path to the urlpatterns list
	from pages.views import home_view
	path('', home_view, name='home'),

------------------------
URL ROUTING AND REQUESTS
------------------------
Routing is just is just putting a path extention in the first argument of, path('', home_view, name='home').
If the first argument is like so, path('contact/', home_view, name='home'),
typing 'contact/' at the end of our server url like this, http://127.0.0.1:8000/contact/
will take us to the page view specified in the 'path()' function

The url is a request, and the url extension, i.e. 'contact/' and 'admin/' is an item page that is being requested

# the *args and **kwargs print out (<WSGIRequest: GET '/'>,) {}
# request.user prints out the user accessing the server, saeed
# When accessed from a different browser, incognito browser or maybe after logging out
# request.user prints out the user accessing the server, AnonymousUser

RECAP:
	Going to a url is like knocking on a door, REQUESTing for something
	The server, i.e. django, returns a response to us that can be seen in the browser
	Django recognizes the url, web address, being requested
		Breaks it apart
		Figures out which function is going to respond to the particular REQUEST
		The function will the respond with some sort of HTTP response
		HttpResponse() being the most basic
		HttpResponse() can take a string of http or http code itself

----------------
DJANGO TEMPLATES
----------------
RECAP:
	Going to a url is like knocking on a door, REQUESTing for something
	The server, i.e. django, returns a response to us that can be seen in the browser
	Django recognizes the url, web address, being requested
		Breaks it apart
		Figures out which function is going to respond to the particular REQUEST
		The function will the respond with some sort of HTTP response
		HttpResponse() being the most basic
		HttpResponse() can take a string of http or http code itself

However, instead of writing the string of HTML code and passing it to HttpResponse(),
we can use some django shortcuts, like 'render'.
We can use render to return an html template file or other html document, like so;
	return render(request, "home.html",{})

Create the html template folder inside the src folder
Create you html file
Go into the settings.py file,
	under TEMPLATES dictionary,
		in 'DIRS' entry
			where we will put the path to the templates folder in the entry value
				'DIRS': ['/mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango/src/templates']

			But hardcoding does not work with a different user on a different machine
			in that case, using the BASE_DIR path at the top of the settings.py folder is a lot better
			And we implement the code like so:
				'DIRS': [os.path.join(BASE_DIR,'templates')]

-------------------------------
DJANGO TEMPLATING ENGINE BASICS
-------------------------------
we can use the following commands to print the user accessing the url onto the page
and also flag True or False if the user have logged in:
	{{ request.user}}
	{{ request.user.is_authenticated}}

However, we can see that the views.py uses multiple .html files depending on the number of
pages being rendered
These html files might actually share attributes across each one of them. Attributes like:
	Navigation bar, or some metadata like the title tag, the description, and other metadata or cssdata
	There are a lot of these attributes that might be shared accross the html pages
	This is where "Template Inheritance" comes in

Create a root page within the templates folder.
	This page will where all the other pages borrow from
	Call it 'base.html'
	'base.html' is convention, so that is what it is called universally

--------------------
INCLUDE TEMPLATE TAG
--------------------
Inheritance allows us to remove redundant code that will be needed in many html files
Inheritance allows us to have the code defined once, and can be referenced many time over

We can also create an html script that we want to include in all the website pages, such as
the navigation bar. We can create the navbar.html file in the templates folder.
After creating the navbar.html script, we can then import it into the body of our base.html
file, like so:
	{% include 'navbar.html' %}

-------------------------------
RENDERING CONTEXT IN A TEMPLATE
-------------------------------
The main use of templates is to fetch data from the back-end, i.e. data from the database,
to be rendered out inside templates such as using {{ request.user }}.
But more complext operations can be made using templates such as changing the title of the
page or having different content within the pages based on the user accessing it.

Template context
----------------

Navigate to trydjango >> src >> pages >> views.py
	the empty dictionary {} in the return command,
		"return render(request, "home.html",{})"
	is where we can pass in our context into the page

Django mashes the template and context together, renders it, and then sends back raw html
to the browser.

Context:
	This can be any data type

Create and deploy context:
	Create a dictionary and fill it up, like so:
		my_context = {
			"my_text"	: "This is my contact",
			"my_number"	: 12369
			}
	Then pass in the new dictionary in the empty dictionary, like so:
		return render(request, "contact.html",my_context)
	Then navigate to the template html file
	Before the {% endblock %}, enter the following:
		<p>
		    {{ }}
		</p>
	The space within the double braces, {{ }}, will house the context variable.
	The dictionary keys, "my_text" & "my_number", will become the context variables
	that will go within the double braces, like so:
		<p>
		    {{ my_text }}
		</p>
	We can also have multiple context variables being called, like so:
		<p>
		    {{ my_text }}, {{ my_number }}
		</p>

