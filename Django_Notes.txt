---------
DJANGO
---------

Source: 	https://www.youtube.com/watch?v=F5mRW0jo-U4
Code:   	https://github.com/codingforentrepreneurs/Try-Django
Setup:  	joincfe.com/from-zero
env:    	django
activate: 	cd ~/Dev/venv/ && source bin/activate
windows ubuntu: cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango && source bin/activate
Launch django:	cd src && python manage.py runserver
-------------------------------------------------------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-------------------------------------------------------------------------------------------------
CREATING A NEW DJANGO PROJECT
-----------------------------

Launch django:	cd src && python manage.py runserver
Sync Settings:	python manage.py migrate

--------------------------------------------------
Create superuser: python manage.py createsuperuser
--------------------------------------------------
username:	saeed
password:	default password + 'a'

Create apps: 	python manage.py startapp products
		python manage.py startapp yaomul-khamis

Add apps:	python manage.py makemigrations
		python manage.py migrate

Shell Add:	cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango/src && python manage.py shell
		>>> from products.models import Product
		>>> Product.objects.all()
		<QuerySet [<Product: Product object (1)>]>
		>>> Product.objects.create(title='New products2', description='Itssanother one', price='9.99', summary='Sweetness') 
		<Product: Product object (2)>
		>>> Product.objects.all()
		<QuerySet [<Product: Product object (1)>, <Product: Product object (2)>]>
		>>> Product.objects.create(title='New products3', description='Itssanother one, again', price='9.99', summary='Awesomeness')
		>>> Product.objects.all()
		<QuerySet [<Product: Product object (1)>, <Product: Product object (2)>, <Product: Product object (3)>]>

----------------
NEW MODEL FIELDS
----------------
Star over:	Delete all the files in the products >> migrations folder including __pycache__ folder except the __init__.py file
		Delete the sqlite database under the src tree
		
"python manage.py createsuperuser": this is because the sqlite database was deleted

Field types:	Use django documentation to find different field types to use

Shell Add with the new fields:
		>>> from products.models import Product
		>>> Product.objects.create(title='Newer title', price=29.99, summary='Awesomeness')
		<Product: Product object (2)>

--------------
CHANGE A MODEL
--------------
trydjango >> src >> products >> model.py

Make a change to the model without deleting the database
When we run "python manage.py makemigrations", it syncs our database to the model
However, if we add a field to our model, we need to let the database know
The command, "python manage.py makemigrations", allows the database to know about the changes

# blank=True, null=False  makes the 'Summary' not bold and not essential to be filled before saving in server admin
# blank=False, null=False  makes the 'Summary' bold and essential to be filled before saving in server admin
# 'blank' has to do with how the field is rendered
# 'null' has to do with the database
# 'blank=False' means it is required
# 'null=False' means the database can be empty

-----------------------------------
DEFAULT HOMEPAGE TO CUSTOM HOMEPAGE
-----------------------------------
Create a new app called pages:
	python manage.py startapp pages

Add the new app, pages to settings.py under INSTALLED APPS = [...]
	trydjango >> src >> trydjango >> settings.py

Navigate to views.py
	trydjango >> src >> pages >> views.py

Build the homepage function in views.py
Import the views.py code into urls.py
	trydjango >> src >> trydjango >> urls.py
Add the home view path to the urlpatterns list
	from pages.views import home_view
	path('', home_view, name='home'),

------------------------
URL ROUTING AND REQUESTS
------------------------
Routing is just is just putting a path extention in the first argument of, path('', home_view, name='home').
If the first argument is like so, path('contact/', home_view, name='home'),
typing 'contact/' at the end of our server url like this, http://127.0.0.1:8000/contact/
will take us to the page view specified in the 'path()' function

The url is a request, and the url extension, i.e. 'contact/' and 'admin/' is an item page that is being requested

# the *args and **kwargs print out (<WSGIRequest: GET '/'>,) {}
# request.user prints out the user accessing the server, saeed
# When accessed from a different browser, incognito browser or maybe after logging out
# request.user prints out the user accessing the server, AnonymousUser

RECAP:
	Going to a url is like knocking on a door, REQUESTing for something
	The server, i.e. django, returns a response to us that can be seen in the browser
	Django recognizes the url, web address, being requested
		Breaks it apart
		Figures out which function is going to respond to the particular REQUEST
		The function will the respond with some sort of HTTP response
		HttpResponse() being the most basic
		HttpResponse() can take a string of http or http code itself

----------------
DJANGO TEMPLATES
----------------
RECAP:
	Going to a url is like knocking on a door, REQUESTing for something
	The server, i.e. django, returns a response to us that can be seen in the browser
	Django recognizes the url, web address, being requested
		Breaks it apart
		Figures out which function is going to respond to the particular REQUEST
		The function will the respond with some sort of HTTP response
		HttpResponse() being the most basic
		HttpResponse() can take a string of http or http code itself

However, instead of writing the string of HTML code and passing it to HttpResponse(),
we can use some django shortcuts, like 'render'.
We can use render to return an html template file or other html document, like so;
	return render(request, "home.html",{})

Create the html template folder inside the src folder
Create you html file
Go into the settings.py file,
	under TEMPLATES dictionary,
		in 'DIRS' entry
			where we will put the path to the templates folder in the entry value
				'DIRS': ['/mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango/src/templates']

			But hardcoding does not work with a different user on a different machine
			in that case, using the BASE_DIR path at the top of the settings.py folder is a lot better
			And we implement the code like so:
				'DIRS': [os.path.join(BASE_DIR,'templates')]

-------------------------------
DJANGO TEMPLATING ENGINE BASICS
-------------------------------
we can use the following commands to print the user accessing the url onto the page
and also flag True or False if the user have logged in:
	{{ request.user}}
	{{ request.user.is_authenticated}}

However, we can see that the views.py uses multiple .html files depending on the number of
pages being rendered
These html files might actually share attributes across each one of them. Attributes like:
	Navigation bar, or some metadata like the title tag, the description, and other metadata or cssdata
	There are a lot of these attributes that might be shared accross the html pages
	This is where "Template Inheritance" comes in

Create a root page within the templates folder.
	This page will where all the other pages borrow from
	Call it 'base.html'
	'base.html' is convention, so that is what it is called universally

--------------------
INCLUDE TEMPLATE TAG
--------------------
Inheritance allows us to remove redundant code that will be needed in many html files
Inheritance allows us to have the code defined once, and can be referenced many time over

We can also create an html script that we want to include in all the website pages, such as
the navigation bar. We can create the navbar.html file in the templates folder.
After creating the navbar.html script, we can then import it into the body of our base.html
file, like so:
	{% include 'navbar.html' %}

-------------------------------
RENDERING CONTEXT IN A TEMPLATE
-------------------------------
The main use of templates is to fetch data from the back-end, i.e. data from the database,
to be rendered out inside templates such as using {{ request.user }}.
But more complext operations can be made using templates such as changing the title of the
page or having different content within the pages based on the user accessing it.

Template context
----------------

Navigate to trydjango >> src >> pages >> views.py
	the empty dictionary {} in the return command,
		"return render(request, "home.html",{})"
	is where we can pass in our context into the page

Django mashes the template and context together, renders it, and then sends back raw html
to the browser.

Context:
	This can be any data type

Create and deploy context:
	Create a dictionary and fill it up, like so:
		my_context = {
			"my_text"	: "This is my contact",
			"my_number"	: 12369
			}
	Then pass in the new dictionary in the empty dictionary, like so:
		return render(request, "contact.html",my_context)
	Then navigate to the template html file
	Before the {% endblock %}, enter the following:
		<p>
		    {{ }}
		</p>
	The space within the double braces, {{ }}, will house the context variable.
	The dictionary keys, "my_text" & "my_number", will become the context variables
	that will go within the double braces, like so:
		<p>
		    {{ my_text }}
		</p>
	We can also have multiple context variables being called, like so:
		<p>
		    {{ my_text }}, {{ my_number }}
		</p>

--------------------
FOR LOOP IN TEMPLATE
--------------------
The wrong way to render a list is to render out the list as different variables in view.py
Like so, within the def function in views.py:
	for item in [123,456,789]:
		my_context['item1'] = item

The templates themselves can have this sort of flow.
We just need to go into the template and implement a loop on any given context object, context variable.
The following will iterate through every item in my_list:
	<ul>
		{% for my_sub_item in my_list %}
		<li>{{ my_sub_item }}</li>
		{% endfor %}
	</ul>
Number the list items with:
	<ul>
		{% for my_sub_item in my_list %}
		<li>{{ forloop.counter}} - {{ my_sub_item }}</li>
		{% endfor %}
	</ul>

------------------------------
USING CONDITIONS IN A TEMPLATE
------------------------------
Using conditional statement like "if" "elif" and "else" statements can be constructed
like so:
	<ul>
		{% for my_sub_item in my_list %}
		    {% if my_sub_item == 123 %}
		        <li>{{ forloop.counter}} - {{ my_sub_item|add:22 }}</li>
		    {% elif my_sub_item == "Abc" %}
			<li>This is not a network</li>
		    {% else %}
			<li>{{ forloop.counter}} - {{ my_sub_item }}</li>
		    {% endif %}
		{% endfor %}
	</ul>

The for loop and "if" "elif" and "else" conditional statement above lists the contents
of a list in a dictionary in views.py onto the "contact" webpage
The operation: 
	loops through the content of my_list
		if the my_list[i] == 123:
		   print(add 22 to the number in my_list[i])
		elseif my_list[i] == "Abc"
		   print("This is not a network")
		else
		   print(my_list[i])
		end if

These "if", "elif", "else", "for" are are built-in template tags

-------------------------
TEMPLATE TAGS AND FILTERS
-------------------------
A rule of thumb, if you see "{{", you will probably be able to use a pipe and then some
filter in there.
"add" is a filter we used to add 22 to the value of my_list[i] in the conditional
statement above.

You can use "add" to:
	add numbers or a string that represent numbers
	add variables
	
You can use the filter "capfirst" to make sure your text string always start with a
capital letter.
The following shows how the filter is utilized
	{{ title|capfirst }}

simple right?!
We can also use multiple filters by stacking them together.
The following implementation first capitalizes the first letter,
Then converts the remaining letters into their upper case forms
	{{ title|capfirst|upper }}

When we pass in an html as a context variable within the my_context dictionary
in views.py, like so:
	"my_html"	: "<h1>Hello World</h1>"

when it is rendered like so:
	{{ my_html }}

by default, it is rendered as the exact same text in the my_html key value, like so:
	<h1>Hello World</h1>

However, using the filter "safe" or "striptags" like so:
	{{ my_html|safe }}
	{{ my_html|striptags}}

will render the text properly by stipping the html tags like so:
	Hello World

The filter "title" titlizes the entire text by capitalizing the first letter of each word

------------------------------------------
RENDER DATA FROM THE DATABASE WITH A MODEL
------------------------------------------
Lets play on the shell for a minute to see how to call for model items
Activate python shell on ubuntu
	cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango && source bin/activate
	cd src && python manage.py shell

	>>> from products.models import Product
	>>> Product.objects.get(id=1)
	    <Product: Product object (1)>
# django automatically creates the id for us depending on the number of products our
  project has
	>>> obj = Product.objects.get(id=1)
	>>> dir(obj)

This will output all the methods the Product object has such as:
	'__class__', '__delattr__', '__dict__', '__dir__', '__doc__'
	'price', 'refresh_from_db', 'save', 'save_base', 'summary', 'title',

You can also call for items unique to the model such as 'title','summary','price' like so:
	>>> obj.title
	   'New Product'
	>>> obj.price
	   Decimal('1.54')
	>>> obj.summary
	   'New Summary!'

Navigate to views.py under the 'products' folder
This is to make sure everything related to your products is within the products app, folder
	Create you product_detail_view function in product/views.py
	Navigate to the templates folder
	Create a new folder called "product" within the templates folder
	Create a new file within this product folder and name it detail.html
	Put your html code in detail.html like so:
		{% extends 'base.html' %}

		{% block content %}
		<h1>Item</h1>
		{% endblock %}
	Navigate to trydgango folder and open up urls.py
	Import urls to view like so:
		from products.views import product_detail_view
	Make a new path within the urlpatterns list like so:
		path('product/', product_detail_view)
	Navigate to your product webpage like so:
		http://127.0.0.1:8000/product/
	You should see the h1 render of "Item"

We can now render product from the database such as title and description via detail.html
like so:
	{% extends 'base.html' %}

	{% block content %}
	<h1>{{ title }}</h1>
	<p>
	    {% if description != None and description != '' %}
	        {{ description }}
	    {% else %}
		Description Coming Soon
	    {% endif %}
	</p>
	{% endblock %}

In other to avoid limiting oneself to the object items declared in the context variable
within the product_detail_view function, we should pass in the entire object into the 
context variable instead, like so:
	context = {
		'object': obj
	}

This will modify our detail.html content to look like so:
	{% extends 'base.html' %}

	{% block content %}
	<h1>{{ object.title }}</h1>
	<p>
	    {% if object.description != None and object.description != '' %}
	        {{ object.description }}
	    {% else %}
		Description Coming Soon
	    {% endif %}
	</p>
	{% endblock %}

-----------------------------------
HOW DJANGO TEMPLATES LOAD WITH APPS
-----------------------------------
Because we want all our codes under the "products" folder, we will then:
	Create a templates folder within products
	Create a products folder within templates folder
	Create product_detail.html file within the products folder
	Copy the contents of templates/product/detail.html into the product_detail.html file
	Delete templates/product folder

------------------
DJANGO MODEL FORMS
------------------
We want to allow the users to save data in the database without using the admin or
python shell, so;
Lets break down the basics of using Django Model Forms
Inside of any given app:
	Make a new file in products with the name, forms.py.
	Create your ProductForm class
	Render the ProductForm out in views.py
	Create a form html file with the name, product_create.html
	Create a form html element in the product_create.html file with the the following
	html codes
		<form>
		   {{ form.as_p }}
		   <!-- .as_p this turns the form element that is being passed in as context
		   into an actual html form rendered out with paragraph text? -->
		   <input type='submit' value='Save' />
		</form>
	Bring the product_create_view function into our urls as 'create'
	Navigate to your create webpage like so:
		http://127.0.0.1:8000/create/
	Enter values into the fiels provided like so:
		Title: 		New Product 3
		Description: 	This is awesome
		Price:		5.50
	And then click save.
	The url will now have the following after "create/"
		?title=+New+Product+3&description=This+is+awesome&price=5.50
	This is an indication that the method used on the form itself wasnt specified
	So go back to product_create.html and replace
	<form> with <form method='POST'> {% csrf_token %} like so:
		<form method='POST'> {% csrf_token %}
		   {{ form.as_p }}
		   <!-- .as_p this turns the form element that is being passed in as context
		   into an actual html form rendered out with paragraph text? -->
		   <input type='submit' value='Save' />
		</form>
	
	If we try to enter values into the fields again we will get this error:
		NOT NULL constraint failed: products_product.featured
	This is because in our models.py Product class, featured = models.BooleanField()
	We just need to replace () with (default=False)

We've now made changes to our model so we need to makemigrations, like so:
	cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango && source bin/activate
	cd src
	python manage.py makemigrations
	python manage.py migrate

Now try to enter values into the fields again and save.
We cant tell if anything has been done because the field values remain as typed
We can go into the admin to find out of the new product has been saved or do it through
python shell.
To clear out the values entered into the fields after hitting save is by
re-rendering the form object after the form.save() line like so:
	form = ProductForm(request.POST or None)
	if form.is_valid():
	   form.save()
	   form = ProductForm()

-------------
RAW HTML FORM
-------------
