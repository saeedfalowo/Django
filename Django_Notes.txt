---------
DJANGO
---------

Source: 	https://www.youtube.com/watch?v=F5mRW0jo-U4
Code:   	https://github.com/codingforentrepreneurs/Try-Django
Setup:  	joincfe.com/from-zero
env:    	django
activate: 	cd ~/Dev/venv/ && source bin/activate
windows ubuntu: cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango && source bin/activate
Launch django:	cd src && python manage.py runserver
-------------------------------------------------------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-------------------------------------------------------------------------------------------------
CREATING A NEW DJANGO PROJECT
-----------------------------

Launch django:	cd src && python manage.py runserver
Sync Settings:	python manage.py migrate

--------------------------------------------------
Create superuser: python manage.py createsuperuser
--------------------------------------------------
username:	saeed
password:	default password + 'a'

Create apps: 	python manage.py startapp products
		python manage.py startapp yaomul-khamis

Add apps:	python manage.py makemigrations
		python manage.py migrate

Shell Add:	cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango/src && python manage.py shell
		>>> from products.models import Product
		>>> Product.objects.all()
		<QuerySet [<Product: Product object (1)>]>
		>>> Product.objects.create(title='New products2', description='Itssanother one', price='9.99', summary='Sweetness') 
		<Product: Product object (2)>
		>>> Product.objects.all()
		<QuerySet [<Product: Product object (1)>, <Product: Product object (2)>]>
		>>> Product.objects.create(title='New products3', description='Itssanother one, again', price='9.99', summary='Awesomeness')
		>>> Product.objects.all()
		<QuerySet [<Product: Product object (1)>, <Product: Product object (2)>, <Product: Product object (3)>]>

----------------
NEW MODEL FIELDS
----------------
Star over:	Delete all the files in the products >> migrations folder including __pycache__ folder except the __init__.py file
		Delete the sqlite database under the src tree
		
"python manage.py createsuperuser": this is because the sqlite database was deleted

Field types:	Use django documentation to find different field types to use

Shell Add with the new fields:
		>>> from products.models import Product
		>>> Product.objects.create(title='Newer title', price=29.99, summary='Awesomeness')
		<Product: Product object (2)>

--------------
CHANGE A MODEL
--------------
trydjango >> src >> products >> model.py

Make a change to the model without deleting the database
When we run "python manage.py makemigrations", it syncs our database to the model
However, if we add a field to our model, we need to let the database know
The command, "python manage.py makemigrations", allows the database to know about the changes

# blank=True, null=False  makes the 'Summary' not bold and not essential to be filled before saving in server admin
# blank=False, null=False  makes the 'Summary' bold and essential to be filled before saving in server admin
# 'blank' has to do with how the field is rendered
# 'null' has to do with the database
# 'blank=False' means it is required
# 'null=False' means the database can be empty

-----------------------------------
DEFAULT HOMEPAGE TO CUSTOM HOMEPAGE
-----------------------------------
Create a new app called pages:
	python manage.py startapp pages

Add the new app, pages to settings.py under INSTALLED APPS = [...]
	trydjango >> src >> trydjango >> settings.py

Navigate to views.py
	trydjango >> src >> pages >> views.py

Build the homepage function in views.py
Import the views.py code into urls.py
	trydjango >> src >> trydjango >> urls.py
Add the home view path to the urlpatterns list
	from pages.views import home_view
	path('', home_view, name='home'),

------------------------
URL ROUTING AND REQUESTS
------------------------
Routing is just is just putting a path extention in the first argument of, path('', home_view, name='home').
If the first argument is like so, path('contact/', home_view, name='home'),
typing 'contact/' at the end of our server url like this, http://127.0.0.1:8000/contact/
will take us to the page view specified in the 'path()' function

The url is a request, and the url extension, i.e. 'contact/' and 'admin/' is an item page that is being requested

# the *args and **kwargs print out (<WSGIRequest: GET '/'>,) {}
# request.user prints out the user accessing the server, saeed
# When accessed from a different browser, incognito browser or maybe after logging out
# request.user prints out the user accessing the server, AnonymousUser

RECAP:
	Going to a url is like knocking on a door, REQUESTing for something
	The server, i.e. django, returns a response to us that can be seen in the browser
	Django recognizes the url, web address, being requested
		Breaks it apart
		Figures out which function is going to respond to the particular REQUEST
		The function will the respond with some sort of HTTP response
		HttpResponse() being the most basic
		HttpResponse() can take a string of http or http code itself

----------------
DJANGO TEMPLATES
----------------
RECAP:
	Going to a url is like knocking on a door, REQUESTing for something
	The server, i.e. django, returns a response to us that can be seen in the browser
	Django recognizes the url, web address, being requested
		Breaks it apart
		Figures out which function is going to respond to the particular REQUEST
		The function will the respond with some sort of HTTP response
		HttpResponse() being the most basic
		HttpResponse() can take a string of http or http code itself

However, instead of writing the string of HTML code and passing it to HttpResponse(),
we can use some django shortcuts, like 'render'.
We can use render to return an html template file or other html document, like so;
	return render(request, "home.html",{})

Create the html template folder inside the src folder
Create you html file
Go into the settings.py file,
	under TEMPLATES dictionary,
		in 'DIRS' entry
			where we will put the path to the templates folder in the entry value
				'DIRS': ['/mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango/src/templates']

			But hardcoding does not work with a different user on a different machine
			in that case, using the BASE_DIR path at the top of the settings.py folder is a lot better
			And we implement the code like so:
				'DIRS': [os.path.join(BASE_DIR,'templates')]

-------------------------------
DJANGO TEMPLATING ENGINE BASICS
-------------------------------
we can use the following commands to print the user accessing the url onto the page
and also flag True or False if the user have logged in:
	{{ request.user}}
	{{ request.user.is_authenticated}}

However, we can see that the views.py uses multiple .html files depending on the number of
pages being rendered
These html files might actually share attributes across each one of them. Attributes like:
	Navigation bar, or some metadata like the title tag, the description, and other metadata or cssdata
	There are a lot of these attributes that might be shared accross the html pages
	This is where "Template Inheritance" comes in

Create a root page within the templates folder.
	This page will where all the other pages borrow from
	Call it 'base.html'
	'base.html' is convention, so that is what it is called universally

--------------------
INCLUDE TEMPLATE TAG
--------------------
Inheritance allows us to remove redundant code that will be needed in many html files
Inheritance allows us to have the code defined once, and can be referenced many time over

We can also create an html script that we want to include in all the website pages, such as
the navigation bar. We can create the navbar.html file in the templates folder.
After creating the navbar.html script, we can then import it into the body of our base.html
file, like so:
	{% include 'navbar.html' %}

-------------------------------
RENDERING CONTEXT IN A TEMPLATE
-------------------------------
The main use of templates is to fetch data from the back-end, i.e. data from the database,
to be rendered out inside templates such as using {{ request.user }}.
But more complext operations can be made using templates such as changing the title of the
page or having different content within the pages based on the user accessing it.

Template context
----------------

Navigate to trydjango >> src >> pages >> views.py
	the empty dictionary {} in the return command,
		"return render(request, "home.html",{})"
	is where we can pass in our context into the page

Django mashes the template and context together, renders it, and then sends back raw html
to the browser.

Context:
	This can be any data type

Create and deploy context:
	Create a dictionary and fill it up, like so:
		my_context = {
			"my_text"	: "This is my contact",
			"my_number"	: 12369
			}
	Then pass in the new dictionary in the empty dictionary, like so:
		return render(request, "contact.html",my_context)
	Then navigate to the template html file
	Before the {% endblock %}, enter the following:
		<p>
		    {{ }}
		</p>
	The space within the double braces, {{ }}, will house the context variable.
	The dictionary keys, "my_text" & "my_number", will become the context variables
	that will go within the double braces, like so:
		<p>
		    {{ my_text }}
		</p>
	We can also have multiple context variables being called, like so:
		<p>
		    {{ my_text }}, {{ my_number }}
		</p>

--------------------
FOR LOOP IN TEMPLATE
--------------------
The wrong way to render a list is to render out the list as different variables in view.py
Like so, within the def function in views.py:
	for item in [123,456,789]:
		my_context['item1'] = item

The templates themselves can have this sort of flow.
We just need to go into the template and implement a loop on any given context object, context variable.
The following will iterate through every item in my_list:
	<ul>
		{% for my_sub_item in my_list %}
		<li>{{ my_sub_item }}</li>
		{% endfor %}
	</ul>
Number the list items with:
	<ul>
		{% for my_sub_item in my_list %}
		<li>{{ forloop.counter}} - {{ my_sub_item }}</li>
		{% endfor %}
	</ul>

------------------------------
USING CONDITIONS IN A TEMPLATE
------------------------------
Using conditional statement like "if" "elif" and "else" statements can be constructed
like so:
	<ul>
		{% for my_sub_item in my_list %}
		    {% if my_sub_item == 123 %}
		        <li>{{ forloop.counter}} - {{ my_sub_item|add:22 }}</li>
		    {% elif my_sub_item == "Abc" %}
			<li>This is not a network</li>
		    {% else %}
			<li>{{ forloop.counter}} - {{ my_sub_item }}</li>
		    {% endif %}
		{% endfor %}
	</ul>

The for loop and "if" "elif" and "else" conditional statement above lists the contents
of a list in a dictionary in views.py onto the "contact" webpage
The operation: 
	loops through the content of my_list
		if the my_list[i] == 123:
		   print(add 22 to the number in my_list[i])
		elseif my_list[i] == "Abc"
		   print("This is not a network")
		else
		   print(my_list[i])
		end if

These "if", "elif", "else", "for" are are built-in template tags

-------------------------
TEMPLATE TAGS AND FILTERS
-------------------------
A rule of thumb, if you see "{{", you will probably be able to use a pipe and then some
filter in there.
"add" is a filter we used to add 22 to the value of my_list[i] in the conditional
statement above.

You can use "add" to:
	add numbers or a string that represent numbers
	add variables
	
You can use the filter "capfirst" to make sure your text string always start with a
capital letter.
The following shows how the filter is utilized
	{{ title|capfirst }}

simple right?!
We can also use multiple filters by stacking them together.
The following implementation first capitalizes the first letter,
Then converts the remaining letters into their upper case forms
	{{ title|capfirst|upper }}

When we pass in an html as a context variable within the my_context dictionary
in views.py, like so:
	"my_html"	: "<h1>Hello World</h1>"

when it is rendered like so:
	{{ my_html }}

by default, it is rendered as the exact same text in the my_html key value, like so:
	<h1>Hello World</h1>

However, using the filter "safe" or "striptags" like so:
	{{ my_html|safe }}
	{{ my_html|striptags}}

will render the text properly by stipping the html tags like so:
	Hello World

The filter "title" titlizes the entire text by capitalizing the first letter of each word

------------------------------------------
RENDER DATA FROM THE DATABASE WITH A MODEL
------------------------------------------
Lets play on the shell for a minute to see how to call for model items
Activate python shell on ubuntu
	cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango && source bin/activate
	cd src && python manage.py shell

	>>> from products.models import Product
	>>> Product.objects.get(id=1)
	    <Product: Product object (1)>
# django automatically creates the id for us depending on the number of products our
  project has
	>>> obj = Product.objects.get(id=1)
	>>> dir(obj)

This will output all the methods the Product object has such as:
	'__class__', '__delattr__', '__dict__', '__dir__', '__doc__'
	'price', 'refresh_from_db', 'save', 'save_base', 'summary', 'title',

You can also call for items unique to the model such as 'title','summary','price' like so:
	>>> obj.title
	   'New Product'
	>>> obj.price
	   Decimal('1.54')
	>>> obj.summary
	   'New Summary!'

Navigate to views.py under the 'products' folder
This is to make sure everything related to your products is within the products app, folder
	Create you product_detail_view function in product/views.py
	Navigate to the templates folder
	Create a new folder called "product" within the templates folder
	Create a new file within this product folder and name it detail.html
	Put your html code in detail.html like so:
		{% extends 'base.html' %}

		{% block content %}
		<h1>Item</h1>
		{% endblock %}
	Navigate to trydgango folder and open up urls.py
	Import urls to view like so:
		from products.views import product_detail_view
	Make a new path within the urlpatterns list like so:
		path('product/', product_detail_view)
	Navigate to your product webpage like so:
		http://127.0.0.1:8000/product/
	You should see the h1 render of "Item"

We can now render product from the database such as title and description via detail.html
like so:
	{% extends 'base.html' %}

	{% block content %}
	<h1>{{ title }}</h1>
	<p>
	    {% if description != None and description != '' %}
	        {{ description }}
	    {% else %}
		Description Coming Soon
	    {% endif %}
	</p>
	{% endblock %}

In other to avoid limiting oneself to the object items declared in the context variable
within the product_detail_view function, we should pass in the entire object into the 
context variable instead, like so:
	context = {
		'object': obj
	}

This will modify our detail.html content to look like so:
	{% extends 'base.html' %}

	{% block content %}
	<h1>{{ object.title }}</h1>
	<p>
	    {% if object.description != None and object.description != '' %}
	        {{ object.description }}
	    {% else %}
		Description Coming Soon
	    {% endif %}
	</p>
	{% endblock %}

-----------------------------------
HOW DJANGO TEMPLATES LOAD WITH APPS
-----------------------------------
Because we want all our codes under the "products" folder, we will then:
	Create a templates folder within products
	Create a products folder within templates folder
	Create product_detail.html file within the products folder
	Copy the contents of templates/product/detail.html into the product_detail.html file
	Delete templates/product folder

------------------
DJANGO MODEL FORMS
------------------
We want to allow the users to save data in the database without using the admin or
python shell, so;
Lets break down the basics of using Django Model Forms
Inside of any given app:
	Make a new file in products with the name, forms.py.
	Create your ProductForm class
	Render the ProductForm out in views.py
	Create a form html file with the name, product_create.html
	Create a form html element in the product_create.html file with the the following
	html codes
		<form>
		   {{ form.as_p }}
		   <!-- .as_p this turns the form element that is being passed in as context
		   into an actual html form rendered out with paragraph text? -->
		   <input type='submit' value='Save' />
		</form>
	Bring the product_create_view function into our urls as 'create'
	Navigate to your create webpage like so:
		http://127.0.0.1:8000/create/
	Enter values into the fiels provided like so:
		Title: 		New Product 3
		Description: 	This is awesome
		Price:		5.50
	And then click save.
	The url will now have the following after "create/"
		?title=+New+Product+3&description=This+is+awesome&price=5.50
	This is an indication that the method used on the form itself wasnt specified
	So go back to product_create.html and replace
	<form> with <form method='POST'> {% csrf_token %} like so:
		<form method='POST'> {% csrf_token %}
		   {{ form.as_p }}
		   <!-- .as_p this turns the form element that is being passed in as context
		   into an actual html form rendered out with paragraph text? -->
		   <input type='submit' value='Save' />
		</form>
	
	If we try to enter values into the fields again we will get this error:
		NOT NULL constraint failed: products_product.featured
	This is because in our models.py Product class, featured = models.BooleanField()
	We just need to replace () with (default=False)

We've now made changes to our model so we need to makemigrations, like so:
	cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango && source bin/activate
	cd src
	python manage.py makemigrations
	python manage.py migrate

Now try to enter values into the fields again and save.
We cant tell if anything has been done because the field values remain as typed
We can go into the admin to find out of the new product has been saved or do it through
python shell.
To clear out the values entered into the fields after hitting save is by
re-rendering the form object after the form.save() line like so:
	form = ProductForm(request.POST or None)
	if form.is_valid():
	   form.save()
	   form = ProductForm()

-------------
RAW HTML FORM
-------------
Lets first get rid of any Django related stuff leaving just the form html element within
the block content, like so:
	{% extends 'base.html' %}

	{% block content %}
	<form method='POST'>
	   <input type='submit' value='Save' />
	</form>

	{% endblock %}

Before the input element for the save button;
	<input type='submit' value='Save' />
Enter a new input element for the form like so:
	<input type='text' name='title' placeholder="Your title"/>

Navigate to your views script and make it so the product_create_view function
only renders out an empty context, like so:
	def product_create_view(request):
	   context = {}
	   return render(request, "products/product_create.html", context)

After saving, the the web address, http://127.0.0.1:8000/create/
should only give out text field with the placeholder "Your title" with a save button right
next to it.
However, typing something within the text field and hitting save will give a "forbidden" error.
That is because of the POST method used in the form element in the html file:
	<form method='POST'>
Replacing that with this:
	<form method='GET'>
Will rectify the problem.
After hitting save, the url will change to include the input recently typed, like so:
	http://127.0.0.1:8000/create/?title=Firstfirst
GET method is the default for form elements, so using <form> without any method specified
will give the same result.

The "POST" method gave us an error due to Djangos security measures being triggered.
If we still want to use the "POST" method, we just need to add a "/search/" action, like so:
	<form action='/search/' method='POST'>
This will make our url look like so:
	http://127.0.0.1:8000/search/
However, we will get a "Page Not Found" error because the action was to find a page that
doesnt exist in the website.
We can use this method to search for something in a different website, like google!
We only need to change the action, method, and name parameters to the website's, like so:
	<form action='http://www.google.com/search' method='GET'>
	   <input type='text' name='q' placeholder="Your title"/>
	   <input type='submit' value='Save' />
	
	</form>
We have just created out own google search form.
Hitting save after typying anything in the text field will search for that input on google.
This shows that the action will change the url to whatever url is put there.

However, by default:
	"action='.'" or "action=''"
The action goes to the current url

WHAT ARE GET AND POST Methods???
"GET" means you go to any url, you are getting information from there
"POST" is used to save any information in the backend.

This is why using the "POST" method for a google search form will yield a 405 error.
We cant save any information in google's backend!

We can print into our backend by printing using:
	print(request.GET)
If we type in anything in our text field, we will see it printed in our ubuntu backend
However, using GET to save data is an unsafe method.

----------------
PURE DJANGO FORM
----------------
Navigate to your views script and make it so the product_create_view function
only renders out an empty context, like so:
	def product_create_view(request):
	   context = {}
	   return render(request, "products/product_create.html", context)

Navigate to your forms script and create a new class, RawProductForm like so:
	class RawProductForm(forms.Form):
	   title 		= forms.CharField()
	   description		= forms.CharField()
	   price		= forms.DecimalField()

Import the newly created class into the views script like so:
	from .forms import RawProductForm
The render out the form within the product_create_view() function
	Create form instance and add to context like so:
		my_form = RawProductForm()
		context = {"form": my_form}
Navigate to the product_create html file, and create a form element like so:
	<form action='.' method='POST'> {% csrf_token %}
	   {{ form.as_p }}
	   <input type='submit' value='Save' />
	
	</form>
Navigating to the web address http://127.0.0.1:8000/create/
Should give us three text fields, namely:
	Title, Description, Price
If we input anything into these text fields and hit the save button, nothing will happen
This is because we have not saved the data in our backend yet.
To save the input data, navigate back to your product_create_views within views.py
Make the following addition and alteration
	my_form = RawProductForm(request.POST)
	Product.objects.create(**my_form.cleaned_data)
Then render the form again to clear the text fields, like so
	my_form = RawProductForm()

If messages like this
	"This field is required."
is displayed above the text fields, know that this is Djangos validation error

You can get rid of these validation errors and also print out the input data and
encountered errors onto the backend like so:
	my_form = RawProductForm()
	if request.method == "POST":
		my_form = RawProductForm(request.POST)
		if my_form.is_valid():
			# Now the data is good
			print(my_form.cleaned_data)
			Product.objects.create(**my_form.cleaned_data)
		else:
			print(my_form.errors)

	my_form = RawProductForm()

Now the validation error will only come up when you hover over the text field

------------
FORM WIDGETS
------------
We can add properties to the forms by passing in input parameters to the text field objects
Like the CharField and DecimalField.
Navigate to the RawProductForm class within the forms.py script
To make a field to be required or not required, we can simply do this:
	forms.CharField(required=True)
	forms.CharField(required=False)
Default for each form is required, so removing the required parameter altogether will make
the input into the text field mandatory.
The field documentation will tell you what is default.

You can also;
	show different labels for the text field
		forms.CharField(label='')
	define an initial value for the text field
		forms.CharField(initial=9.99)
	add a widget or widget with attributes
		forms.CharField(widget=Textarea)
		forms.CharField(widget=Textarea(attrs={}))
	show a placeholder using widget attributes
		forms.CharField(widget=forms.TextInput(
			attrs={"placeholder": "Whats your title?"}))
		
-----------------------
FORM VALIDATION METHODS
-----------------------
Navigate to ProductForm class within the forms.py script
You can override the any of the fields within the Meta class by simply
initializing a field name outside of the Meta class, like so:

	class ProductForm(forms.ModelForm):
	   title = forms.CharField(
		label='Newerer Title',
		widget=forms.TextInput(
			attrs={"placeholder": "Whats your title?"}
			)
		)
	   class Meta:
		model 	= Product
		fields	= ['title','description','price']

Navigate to the views.py script and comment out any other product_create_view function
Leaving only this product_create_view function uncommented
	def product_create_view(request):
	form = ProductForm(request.POST or None)
	if form.is_valid():
		form.save()
		form = ProductForm()
	
	context = {
		'form': form
	}
	# return render(request, "product/detail.html", context)
	return render(request, "products/product_create.html", context)

What if we want the input title to contain a combination of chars, a word, like "cfe"?
Then what we would do is define a function within the class, like so:
	def clean_<my_field_name>(self, *args, **kwargs):
If the title is the field we want to enforce the rule on:
	def clean_title(self, *args, **kwargs):
Then we can you an if statement raise a validation error is condition is not met, like so:
	if "CFE" in title:
	   raise forms.ValidationError("This is not a valid title")
	return title

When we enter an input that does not contain "CFE" in the title text field,
we should get a validation error message on top of the field saying:
	"This is not a valid title"

We can use this to validate email input as well.
We can check if the email contains @ or ends with combination of char like, "edu"

------------------------
INITIAL VALUES FOR FORMS
------------------------
To set initial values on a form, Navigate to products/views and declare your initial data
within the product_create_view function like so:
	initial_data = {'title': "My intial data"}
Then pass it into the ProductForm object as an "initial" parameter, like so:
	form = ProductForm(request.POST or None, initial=initial_data)

You can also pass in Product objects as initial forms data like so:
	obj = Product.objects.get(id=1)
	form = ProductForm(request.POST or None, instance=obj)

-------------------
DYNAMIC URL ROUTING
-------------------
Now lets change our content based on the url, i.e. dynamic url routing
Navigate to the views.py script and construct the dynamic_lookup_view function, like so:
	def dynamic_lookup_view(request,my_id):
	   obj = Product.objects.get(id=my_id)
	   context = {
		"object": obj
	   }
	   return render(request, "products/product_detail_url_routing.html", context)

Create the product_detail_url_routing.html being referenced like so:
	{% extends 'base.html' %}

	{% block content %}
	<h1>{{ object.title }}</h1>
	<p>{{ object.description }}</p>
	<p>{{ object.price}}</p>
	{% endblock %}

And because we want the url to be dynamic, we need to change the url path in the urls.py
script, like so:
	urlpatterns = [
	   path('products/<int:my_id>/', dynamic_lookup_view, name='product')
	]

We can now navigate between the products we have create on our website like so:
	http://127.0.0.1:8000/products/1/
	http://127.0.0.1:8000/products/2/
	http://127.0.0.1:8000/products/3/
As we can see from the path defined in the urls.py: "path('products/<int:my_id>/"
products/1/, products/2/, products/3/, will help us navigate between the products
we have stored in our backend database

-------------------
HANDLE DOESNOTEXIST
-------------------
We can make it raise a 404 error is a missing object is requested.
	from django.shortcuts import get_object_or_404
And replace the dynamic_lookup_view function like so:
	def dynamic_lookup_view(request,my_id):
	   obj = get_object_or_404(Product, id=my_id)
	   context = {
		"object": obj
	   }
	   return render(request, "products/product_detail_url_routing.html", context)

Navigating to a webpage that does not exist will now give us a "Page not found (404)" error
This is a valid error
This can be achieved with Http404 as well
	from django.http import Http404
And replace the dynamic_lookup_view function like so:
	def dynamic_lookup_view(request,my_id):
	   try:
	      obj = Product.objects.get(id=my_id)
	   except Product.DoesNotExist:
	      raise Http404
	   context = {
		"object": obj
	   }
	   return render(request, "products/product_detail_url_routing.html", context)

------------------
DELETE AND CONFIRM
------------------
Deleting an object is super easy, barely an inconvenience
	obj.delete()
This will only happen on a GET request, but we want it to happen on a POST request
Our product_delete_view function within views.py script will:
	get the object
	confirm the request method is POST
	And redirects the web page back a step after confirming deletion
The function is constructed like so:
	def product_delete_view(request,my_id):
	   obj = get_object_or_404(Product, id=my_id)
	   # POST request
	   if request.method == "POST":
	      obj.delete() # confirming delete
	      return redirect('../') # return one step back
	   context = {
	      "object": obj
	   }
	   return render(request, "products/product_detail_delete.html", context)

The refrenced product_detail_delete.html is constructed like so:
	{% extends 'base.html' %}

	{% block content %}
	<form action='.' method='POST'> {% csrf_token %}
	   <h1>Do you want to delete the product "{{ object.title }}"?</h1>
	   <p><input type='submit' value='Save' /> <a href='../'>Cancel</a></p>
	
	</form>

	{% endblock %}

And import product_delete_view and add the deletion page url to urls.py script like so:
	from products.views import product_delete_view 
	urlpatterns = [	path('products/<int:my_id>/delete/', product_delete_view, name='product-delete')]

----------------------------------
VIEW OF A LIST OF DATABASE OBJECTS
----------------------------------
To list out the objects within the database, we will create the product_list_view function
within the views.py script, like so:
	def product_list_view(request):
	   queryset = Product.objects.all() # list of objects
	   context = { "object_list": queryset }
	   return render(request, "products/product_detail_obj_list.html", context)

The refrenced product_detail_obj_list.html is constructed like so:
	{% extends 'base.html' %}

	{% block content %}

	{{ object_list }}

	{% for instance in object_list %}
	   <p>{{ instance.id }} - {{ instance.title }} </p>
	{% endfor %}

	{% endblock %}

And import product_list_view and add the deletion page url to urls.py script like so:
	from products.views import product_list_view
	urlpatterns = [	path('products/', product_list_view, name='product-list')]

Navigating to this url http://127.0.0.1:8000/products/ should show a list of all the 
products in the database

-----------------------
DYNAMIC LINKING OF URLS
-----------------------
To create a link to the detail of a given product, we can do something like this:
	{% for instance in object_list %}
	   <p>{{ instance.id }} - <a href='/products/{{ instance.id }}/'>
	   {{ instance.title }} </a> </p>
	{% endfor %}

that will take us to the dynamic url defined in href
However, changing anything in the hardcoded url defined in href, will mean the url will
need to be changed everywhere it has been referenced.

This can be made easy by creating a shortcut, an instance method, within our model
that will do this dynamic url linking for us.
Create a get_absolute_url function within the Product class in models.py script, like so:
	def get_absolute_url(self):
	   return f"/products/{self.id}" # "f" denotes f string or string substitution

The html code will also change to look like so:

	{% extends 'base.html' %}

	{% block content %}

	{{ object_list }}

	{% for instance in object_list %}
	   <p>{{ instance.id }} - <a href='{{ instance.get_absolute_url }}'>
	   {{ instance.title }} </a> </p>
	{% endfor %}

	{% endblock %}

If this html file is called product_detail_dynamic_url_linking
the return line in our product_list_view function will now look like so:
	return render(request, "products/product_detail_dynamic_url_linking.html", context)

Navigating to this url http://127.0.0.1:8000/products/ should show a list of all the 
products in the database. Each list element will have a hyperlink that will take us to
their corresponding webpages.

-------------------
DJANGO URLS REVERSE
-------------------
Lets make our get_absolute_url function to become dynamic
as in this string right here:
	f"/products/{self.id}"

We gave our urls within the paths defined in urlpatterns list on purpose.
The string defined above is defined based on the names defined for each url.
We will use "reverse" to accomplish this task, like so:
	return reverse("product", kwargs={"my_id":self.id})
		# "my_id" refers to the integer id declared in products/<int:my_id>/
		# within the url patterns url with the name, product.

Navigating to url http://127.0.0.1:8000/products/ should show a list of all the 
products in the database. Each list element will have a hyperlink that will take us to
their corresponding webpages.
Clicking on any item in the list will take up to the product page
If name argument used is product-delete, clicking on any of the links will take us
to the delete page for the particular product.

---------------------------
IN APP URLS AND NAMESPACING
---------------------------
In other to eliminate confusing urls, we can just create a urls.py script within specific
app. This url.py script will contain only urls pretaining to functions in the app itself.
Then import that products/urls.py urlpatterns into the trydjango/urls.py urlpatterns
But even after that, the web pages might still give us two pages concatenated in one
webpage.
This is when we used namespacing.
We just have to declare the name of the app the urls.py belongs to within the urls.py
itself
The product/urls.py will look like this:
	from django.urls import path

	from .views import (
    		product_detail_view,product_create_view,dynamic_lookup_view,
    		product_delete_view,product_list_view,
    	)

	app_name = 'products'
	urlpatterns = [
    		path('<int:my_id>/detail/', product_detail_view, name='product-detail'),
    		path('create/', product_create_view, name='product-create'),
    		path('<int:my_id>/', dynamic_lookup_view, name='product'),
    		path('<int:my_id>/delete/', product_delete_view, name='product-delete'),
    		path('', product_list_view, name='product-list')
	   ]

And the products/urls.py will be called within the trydjango/urls.py like so:
	from django.contrib import admin
	from django.urls import path, include

	from pages.views import home_view, contact_view
	urlpatterns = [
		path('', home_view, name='home'),
		path('contact/', contact_view, name='home'),
    		path('admin/', admin.site.urls),

    		path('products/', include('products.urls'))
	   ]

And the return line within the get_absolute_url function will be called like so:
	return reverse("products:product", kwargs={"my_id":self.id})

----------------------------
CLASS BASED VIEWS - LISTVIEW
----------------------------
1 - Create a New App named Blog
	cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango && source bin/activate
	cd src && ls
	python manage.py startapp Blog

   The cd src && ls was to make sure you are in your manage.py and db.sqlite3 dir

2 - Add 'Blog' to your Django project
	Navigate to settings.py script and add "Blogs" to the INSTALLED_APPS list

3 - Create a Model named Article
	Navigate to Blogs/models.py and build an Article class, like so:
		class Article(models.Model):
		   title	= models.CharField(max_length=120) 
		   content	= models.TextField(blank=True, null=True)
		   active	= models.BooleanField(default=False)

4 - Run Migrations
	cd /mnt/c/Users/User/Documents/GitHub/Django/Dev/trydjango && source bin/activate
	cd src
	python manage.py makemigrations
	python manage.py migrate

5 - Create a ModelForm for Article
   Create a new file within the Blog folder and name it forms.py
   Construct a Model form for Article like so:
	from django import forms

	from .models import Article

	class ArticleForm(forms.Form):
	   class Meta:
	      model 	= Article
	      fields	= ['title','content','active']

6 - Create 'article_list.html' & 'article_detail.html' Template
   Create a folder within Blog named templates
   Create new files with the names, 'article_list.html' & 'article_detail.html'


7 - Add Article Model to Admin
	from django.contrib import admin
	# Register your models here.
	from .models import Article
	admin.site.register(Article)
	# this is a relative import because admin.py and models.py are in the same module
	# in the same product tree branch

8 - Save a new Article object in admin

------------------------------
CLASS BASED VIEWS - DETAILVIEW
------------------------------
We can get the list and detailed view of our blog like so.
Navigate to views
	from django.shortcuts import render, get_object_or_404

	from django.views.generic import(
	   CreateView, DetailView, ListView,
	   UpdateView, DeleteView
	   )

	from .forms import RawBlogForm

	from .models import Article
	# Create your views here.

	class ArticleListView(ListView):
	   template_name = 'articles/article_list.html'
	   queryset = Article.objects.all()
	   # ListView means it will look for <blog>/<modelname>_list.html

	class ArticleDetailView(DetailView):
	   template_name = 'articles/article_detail.html'
	   #queryset = Article.objects.all()

	# we can use this function to use the article id instead of pk
	   def get_object(self):
		id_ = self.kwargs.get("id")
		return get_object_or_404(Article, id=id_)

Then we add the urls to urls.py, like so:
	path('list', ArticleListView.as_view(), name='article-list'), # as_view turns it into a function based view
	path('<int:id>/', ArticleDetailView.as_view(), name='article-detail'), # id=pk (primary field)

And the html files will look like so:
article_list.html
	{% extends 'base.html' %}

	{% block content %}
	{% for instance in object_list %}
	    <p>{{ instance.id }} - <a href='{{ instance.get_absolute_url }}'>
	{{ instance.title }} </a> </p>
	{% endfor %}

	{% endblock %}

article_detail.html
	{% extends 'base.html' %}

	{% block content %}
	<h1>{{ object.title }}</h1>
	<p>{{ object.content }}</p>
	{% endblock %}


------------------------------
CLASS BASED VIEWS - CREATEVIEW
------------------------------
We can create blogs like so:
Navigate to views.py and build the ArticleCreateView class like so:
	class ArticleCreateView(CreateView):
	   template_name = 'articles/blog_create.html'
	   form_class = ArticleModelForm
	   queryset = Article.objects.all() # <blog>/<modelname>_list.html
	   success_url = '/'

	   def form_valid(self, form):
		print(form.cleaned_data)
		return super().form_valid(form)

	   def get_success_url(self):
	      return '/'

We might get this error:
	ImporperlyConfigured at /Blog/art_create
	No URL to redirect to: Either provide a url or define a get_absolute_url method
	on the model

So that is the reason why we include a get_absolute_url function within our Article class
in models.py script. The function looks like so.
	def get_absolute_url(self):
	   return reverse("articles:article-detail", kwargs={"id":self.id})

This will then redirect the webpage to the article-detail webpage for that particular blog
that was just created.

The redirect page can also be overwritten by these code lines and function as seen in
the ArticleCreateView class above:
	The "success_url = '/'" line will override where the 'save' button will take
	the user
	The "get_success_url" function is another way to override the web address

Build the referenced blog_create.html like so:
	{% extends 'base.html' %}

	{% block content %}
	<form action='.' method='POST'> {% csrf_token %}
	   {{ form.as_p }}
	   <input type='submit' value='Save' />
	
	</form>

	{% endblock %}

And import the url into the urlpatterns list within urls.py script like so:
	path('art_create', ArticleCreateView.as_view(), name='article-create'),


------------------------------
CLASS BASED VIEWS - UPDATEVIEW
------------------------------
The UpdateView will be used to update a specific article
Create the UpdateView class like so:
	class ArticleUpdateView(UpdateView):
	   template_name = 'articles/blog_create.html'
	   form_class = ArticleModelForm
	   queryset = Article.objects.all() # <blog>/<modelname>_list.html
	
	   def get_object(self):
		id_ = self.kwargs.get("id")
		return get_object_or_404(Article, id=id_)

	   def form_valid(self, form):
		print(form.cleaned_data)
		return super().form_valid(form)

The only difference between Create and Update is that Update needs to grab an 
object/instance first before it can be edited.

Include path in urls.py like so:
	from .views import ArticleUpdateView
	app_name = 'articles'
	urlpatterns = [path('<int:id>/update', ArticleUpdateView.as_view(), name='article-update')]

------------------------------
CLASS BASED VIEWS - DELETEVIEW
------------------------------
We use the DeleteView to remove objects
The DeleteView class is very similar to the DetailView class.
The only difference is the template being used.
Create the DeleteView class like so within the views.py script:
	class ArticleDeleteView(DeleteView):
	   template_name = 'articles/article_delete.html'
	   #queryset = Article.objects.all()
	   def get_object(self):
		id_ = self.kwargs.get("id")
		return get_object_or_404(Article, id=id_)

	   def get_success_url(self):
		return reverse('articles:article-list')

After deleting the post, there will be no where to redirect the webpage
That is why the get_success_url function has been included to redirect the webpage to 
the article list page after deleting the specified article post.
Otherwise, the error will prevent the deletion unlike the create view error which will
still create the post despite the redirection error.

Create the article_delete.html template like so:
	{% extends 'base.html' %}

	{% block content %}
	<form action='.' method='POST'> {% csrf_token %}
	   <h1>Do you want to delete the blog post "{{ object.title }}"?</h1>
	   <p><input type='submit' value='Save' /> <a href='../'>Cancel</a></p>
	
	</form>

	{% endblock %}

Include path in urls.py like so:
	from .views import ArticleDeleteView
	app_name = 'articles'
	urlpatterns = [path('<int:id>/update', ArticleUpdateView.as_view(), name='article-update')]


---------------------------------------
FUNCTION BASED VIEW TO CLASS BASED VIEW
---------------------------------------
Here is a simple function based view that just renders out a template:
	from django.shortcuts import render
	
	# HTTP METHODS
	def my_fbv(request, *args, **kwargs):
	   return render(request, 'about.html', {})

To convert this to a class based view, we will inherit from class
	from django.views import View

	# BASE VIEW Class = VIEW
	class CourseView(View):
	   def my_fbv(self, request, *args, **kwargs):
	      return render(request, 'about.html', {})

This will convert the function based view my_fbv into a class based view.
The function within the class based view is almost identical to the one in the function
based view. The only difference is that we need to add the 'self' argument to bring in the
class instance from the CourseView class. Otherwise we will get a META error

	In python, when we say:
		new_obj = CourseView()
	This makes new_obj as an instance of that class, CourseView.
	This will be stored in self to be passed into other functions within the class

So if we declare any variable within the class, like template_name = "about.html"
We will be able to get access to it within a function in that class by passing in self
into the function and accessing the variable like so, self.template_name.

	class CourseView(View):
	   template_name = "about.html"
	   def my_fbv(self, request, *args, **kwargs):
	      return render(request, self.template_name, {})

The function names dont matter in a function based view
But function names within class based view matter, because it should correlate to the HTTP
method that it is trying to handle.
'get' is the default so we will rename our function like so:
	# BASE VIEW Class = VIEW
	class CourseView(View):
	   template_name = "about.html"
	   def get(self, request, *args, **kwargs):
	      return render(request, self.template_name, {})

If you were submitting a form, you will used the post method so your Class based view
will look like so:
	# BASE VIEW Class = VIEW
	class CourseView(View):
	   def post(self, request, *args, **kwargs):
	      return render(request, 'about.html', {})

We can then import the url to the webpage like so in urls.py script

	from django.urls import path
	from .views import CourseView

	app_name = 'courses'
	urlpatterns = [
	   path('', CourseView.as_view(), name='courses-list)
	   ]

We can also overwrite the template used for the view within urls.py like so
	urlpatterns = [
	   path('', CourseView.as_view(template_name='contact.html'), name='courses-list)
	   ]

Using class based views make it easy to change things without messing up too much


---------------------------
RAW DETAIL CLASS BASED VIEW
---------------------------
Lets create a model
	from django.db import models

	class Course(models.Model):
	   title = models.CharField(max_length=120)

Then bring the model into views.py and convert the CourseView to a detail view
To do this, we will pass a parameter from our url
	
	urlpatterns = [
	   path('', CourseView.as_view(template_name='contact.html'), name='courses-list),
	   path('<int:id>/', CourseView.as_view(), name='courses-list)
	   ]

We will want to make both of these urls to be able to work.
To accomplish this, we will pass in id=None into the get function

id=None means that the id is no longer required
id mean that the id is required

	# BASE VIEW Class = VIEW
	class CourseView(View):
	   template_name = "courses/course_detail.html"
	   def get(self, request, id=None, *args, **kwargs):
	      return render(request, self.template_name, {})

Within the courses app folder, we will need to create a templates folder,
then within the templates folder, courses folder
and within the templates/courses dir, we will create a course_detail.html file
The file with have the following template html code:
	{% extends 'base.html' %}

	{% block content %}
	<h1>{{object.id}} - {{ object.title }}</h1>
	{% endblock %}

It is fine to leave the url like this:
	path('<int:id>/', CourseView.as_view(), name='courses-list)

Because the view will run with the defined template_name as default
	template_name = "courses/course_detail.html"

Navigating to the webpage with an id "/courses/1" will this will give a blank webpage
Because no context has been passed into the template itself
To pass in the context, we will add Course class model, and define the object and context
within views.py like so:
	
	from django.shortcuts import render, get_object_or_404
	from django views import View
	form .models import Course
	# BASE VIEW Class = VIEW
	class CourseView(View):
	   template_name = "courses/course_detail.html"
	   def get(self, request, id=None, *args, **kwargs):
	      context = {}
	      if id is not None:
	         obj = get_object_or_404(Course,id=id)
	         context['object'] = obj
	      return render(request, self.template_name, obj)


-------------------------
RAW LIST CLASS BASED VIEW
-------------------------
Build the List view like so

	class CourseListView(View):
	   template_name = "courses/course_list.html"
	   queryset = Course.objects.all()

	   def get(self, request, *args, **kwargs):
	      context = {'object_list': self.queryset}
	      return render(request, self.template_name, context)

Add the view path to urls.py
	from .views import CourseListView
	app_name = 'courses'
	urlpatterns = [
	   path('list', CourseListView.as_view(), name='courses-list')
	   ]

Create a course_list.html within the template/courses directory
	{% extends 'base.html' %}

	{% block content %}

	{% for instance in object_list %}
	   <p>{{ instance.id }} - {{ instance.title }}</p>
	{% endfor %}

	{% endblock %}


Define a get_queryset method function within the CourseListView class in views.py
This will return self.queryset

	class CourseListView(View):
	   template_name = "courses/course_list.html"
	   queryset = Course.objects.all()

	   def get_queryset(self):
	      return render(self.queryset)

	   def get(self, request, *args, **kwargs):
	      context = {'object_list': self.get_queryset()}
	      return render(request, self.template_name, context)

This will give us a list of objects within the product
However, we can call the CourseListView class within another class to define which specific
objects we want in the list, like so

	class MyListView(CourseListView):
	   queryset = Course.objects.filter(id=1)

And we can alter the url path like so:
	from .views import CourseListView, MyListView
	app_name = 'courses'
	urlpatterns = [
	   path('list', MyListView.as_view(), name='courses-list')
	   ]

The webpage will now give us a list of objects with id=1.
Which is just one item
This inheritance property is the biggest advantage of using class based views


---------------------------
RAW CREATE CLASS BASED VIEW
---------------------------
When you create something you want to accept the two methods: GET and POST methods
Build the CourseCreateView class like so:

	# import the form
	from .forms import CourseModelForm
	class CourseCreateView(View):
	   template_name = "courses/course_create.html"

	   # GET METHOD
	   def get(self, request, *args, **kwargs):
	      # GET METHOD
	      form = CourseModelForm() # default=='GET' so leave empty
	      context = {'form': form}
	      return render(request, self.template_name, context)

	   def post(self, request, *args, **kwargs):
	      # POST METHOD
	      form = CourseModelForm(request.POST)
	      if form.is_valid():
	         form.save()
	         form = CourseModelForm() # This re-initialize the actual form clearing the input fields
	      context = {'form': form}
	      # This will grab the form data to be stored in the database
	      return render(request, self.template_name, context)

Construct the create template, course/course_create.html, like so:
	{% extends 'base.html' %}

	{% block content %}
	<form action='.' method='POST'> {% csrf_token %}
	   {{ form.as_p }}
	   <input type='submit' value='Save' />
	
	</form>

	{% endblock %}

Add the view path to urls.py
	from .views import CourseCreateView
	app_name = 'courses'
	urlpatterns = [
	   path('create/', CourseCreateView.as_view(), name='courses-create')
	   ]


-------------------------------
RAW VALIDATION ON A POST METHOD
-------------------------------
Use field validation to prevent the validation error from coming out
on top of the text field on the webpage
Validation error messages like "This field is required"
Field validation can be a functioni within the forms class
We can define the function with this format:
	def clean_<fieldname>

The forms.py script will look like so:

	from django import forms
	from .models import Course

	class CourseModelForm(forms.modelForm):
	   class Meta:
	      model = Course
	      fields = ['title']

	   def clean_title(self):
	      title = self.cleaned_data.get('title')
	      if title.lower() == 'abc':
	         raise forms.ValidationError("This is not a valid title")
	      return title

This validation is only on the forms level, it doesnt do it on the model.


---------------------------
RAW UPDATE CLASS BASED VIEW
---------------------------
Update is a combination of create and detail view

	class CourseUpdateView(View):
	   template_name = "courses/course_update.html"

	   def get_object(self):
		id_ = self.kwargs.get("id")
	        obj = None
	        if id is not None:
	           obj = get_object_or_404(Course, id=id_)
		return obj

	   # GET METHOD
	   def get(self, request, id=None, *args, **kwargs):
	      # GET METHOD
	      context = {}
	      obj = self.get_object()

	      if obj is not None:
	         form = CourseModelForm(instance=obj)
	         context['object'] = obj
	         context['form'] = form
	      return render(request, self.template_name, context)

	   def post(self, request, *args, **kwargs):
	      # POST METHOD
	      context = {}
	      obj = self.get_object()

	      if obj is not None:
	         form = CourseModelForm(request.POST, instance=obj)
	         if form.is_valid():
	            form.save()
	         context['object'] = obj
	         context['form'] = form
	      return render(request, self.template_name, context)

Our courses/course_update.html template will look like so:
	{% extends 'base.html' %}

	{% block content %}
	<h1>Update: {{object.id}} - {{object.title}}</h1>
	<form action='.' method='POST'> {% csrf_token %}
	   {{ form.as_p }}
	   <input type='submit' value='Save' />
	
	</form>

	{% endblock %}

Add the view path to urls.py
	from .views import CourseUpdateView
	app_name = 'courses'
	urlpatterns = [
	   path('<int:id>/update/', CourseUpdateView.as_view(), name='courses-update')
	   ]

---------------------------
RAW DELETE CLASS BASED VIEW
---------------------------
The DeleteView is pretty much identical to the UpdateView
The differences are that we dont need to bring in the form
And we also need to change the html template
And also redirect the webpage to another url after deleting the object

	from django.shortcuts import redirect

	class CourseDeleteView(View):
	   template_name = "courses/course_delete.html"

	   def get_object(self):
		id_ = self.kwargs.get("id")
	        obj = None
	        if id is not None:
	           obj = get_object_or_404(Course, id=id_)
		return obj

	   # GET METHOD
	   def get(self, request, id=None, *args, **kwargs):
	      # GET METHOD
	      context = {}
	      obj = self.get_object()

	      if obj is not None:
	         context['object'] = obj
	      return render(request, self.template_name, context)

	   def post(self, request, *args, **kwargs):
	      # POST METHOD
	      context = {}
	      obj = self.get_object()

	      if obj is not None:
	         obj.delete()
	         context['object'] = None
	         return redirect('/courses/')
	      return render(request, self.template_name, context)

Add the view path to urls.py
	from .views import CourseDeleteView
	app_name = 'courses'
	urlpatterns = [
	   path('<int:id>/delete/', CourseDeleteView.as_view(), name='courses-delete')
	   ]

Create the courses/course_delete.html template like so:
	{% extends 'base.html' %}

	{% block content %}
	<form action='.' method='POST'> {% csrf_token %}
	   <h1>Do you want to delete the blog post "{{ object.title }}"?</h1>
	   <p><input type='submit' value='Save' /> <a href='../'>Cancel</a></p>
	
	</form>

	{% endblock %}


----------------------------------
CUSTOM MIXIN FOR CLASS BASED VIEWS
----------------------------------
Mixins are part of the reason class based views are so good!
It allows us to extend class based views with some new code!

	class CourseObjectMixin(object):
	   model = Course
	   lookup = 'id'

	   def get_object(self):
	      id = self.kwargs.get('id')
	        obj = None
	        if id is not None:
	           obj = get_object_or_404(self.model, id=id)
	      return obj

This will help reduce redundancy inside of my code
We can then get rid of any get_object method function within the code by just passing in
the CourseObjectMixin class into the view classes
Lets use the CourseDeleteView class as an example:

	class CourseDeleteView(CourseObjectMixin, View):
	   template_name = "courses/course_delete.html"

	   """ 
	   def get_object(self):
		id_ = self.kwargs.get("id")
	        obj = None
	        if id is not None:
	           obj = get_object_or_404(Course, id=id_)
		return obj
	   """

	   # GET METHOD
	   def get(self, request, id=None, *args, **kwargs):
	      # GET METHOD
	      context = {}
	      obj = self.get_object()

	      if obj is not None:
	         context['object'] = obj
	      return render(request, self.template_name, context)

	   def post(self, request, *args, **kwargs):
	      # POST METHOD
	      context = {}
	      obj = self.get_object()

	      if obj is not None:
	         obj.delete()
	         context['object'] = None
	         return redirect('/courses/')
	      return render(request, self.template_name, context)

The self.get_object() method called within the class will call for the one in the
CourseObjectMixin class instead.
Note:
	class CourseDeleteView(CourseObjectMixin, View):

CourseObjectMixin method should always come first in the class definition

We can do the same for the CourseView class as well:

	class CourseView(CourseObjectMixin, View):
	   template_name = "courses/course_detail.html"
	   def get(self, request, id=None, *args, **kwargs):
	      context = {'object': self.get_object()}
	      return render(request, self.template_name, obj)

We will not need to define object like this anymore:
	obj = get_object_or_404(Course,id=id)

We can just import it straight from self like so:
	context = {'object': self.get_object()}

We might also need to make sure we are consistent with our lookup variable names as shown:

	class CourseObjectMixin(object):
	   model = Course
	   lookup = 'id'

	   def get_object(self):
	      lookup = self.kwargs.get(self.lookup)
	        obj = None
	        if lookup is not None:
	           obj = get_object_or_404(self.model, lookup=lookup)
	      return obj

However, this makes it a little more challenging so we might just leave it as defined at
the start of this chapter

---------
CEST FINI
---------